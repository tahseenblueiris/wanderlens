structure /wanderlens/backend/

files : 

(main.py)
from fastapi.responses import FileResponse, HTMLResponse
from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
import os
import shutil
import uuid
import sqlite3

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Change to your frontend domain if needed
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")

# Allowed extensions
PHOTO_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".webp"}
VIDEO_EXTENSIONS = {".mp4", ".mov", ".avi", ".mkv", ".webm"}

# Max file sizes
MAX_PHOTO_SIZE = 100 * 1024 * 1024     # 100 MB
MAX_VIDEO_SIZE = 5 * 1024 * 1024 * 1024  # 5 GB

# =======================
# DB Initialization
# =======================
def init_db():
    conn = sqlite3.connect("media.db")
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS media (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT,
                    description TEXT,
                    tags TEXT,
                    media_type TEXT,
                    filename TEXT
                )''')
    conn.commit()
    conn.close()

init_db()

# =======================
# Upload Endpoint
# =======================
@app.post("/upload/")
async def upload_file(
    title: str = Form(...),
    description: str = Form(...),
    tags: str = Form(...),
    media_type: str = Form(...),
    file: UploadFile = File(...)
):
    # Validate media_type
    if media_type not in ['photo', 'video']:
        raise HTTPException(status_code=400, detail="Invalid media_type. Use 'photo' or 'video'.")

    ext = os.path.splitext(file.filename)[1].lower()

    if media_type == 'photo' and ext not in PHOTO_EXTENSIONS:
        raise HTTPException(status_code=400, detail="Only image formats are allowed.")
    if media_type == 'video' and ext not in VIDEO_EXTENSIONS:
        raise HTTPException(status_code=400, detail="Only video formats are allowed.")

    # Read file into memory (check size before saving)
    contents = await file.read()
    file_size = len(contents)

    if media_type == 'photo' and file_size > MAX_PHOTO_SIZE:
        raise HTTPException(status_code=413, detail="Photo size exceeds 100 MB limit.")
    if media_type == 'video' and file_size > MAX_VIDEO_SIZE:
        raise HTTPException(status_code=413, detail="Video size exceeds 5 GB limit.")

    filename = f"{uuid.uuid4().hex}{ext}"
    upload_folder = os.path.join("uploads", f"{media_type}s")
    os.makedirs(upload_folder, exist_ok=True)
    file_path = os.path.join(upload_folder, filename)

    with open(file_path, "wb") as f:
        f.write(contents)

    conn = sqlite3.connect("media.db")
    c = conn.cursor()
    c.execute("INSERT INTO media (title, description, tags, media_type, filename) VALUES (?, ?, ?, ?, ?)",
              (title, description, tags, media_type, filename))
    conn.commit()
    conn.close()

    return {"message": f"{media_type.capitalize()} uploaded successfully", "filename": filename}

# =======================
# Get All Media
# =======================
@app.get("/media/")
def get_all_media():
    conn = sqlite3.connect("media.db")
    c = conn.cursor()
    c.execute("SELECT id, title, description, tags, media_type, filename FROM media ORDER BY id DESC")

    items = []
    for row in c.fetchall():
        file_path = os.path.join("uploads", f"{row[4]}s", row[5])
        if os.path.exists(file_path):
            file_size = os.path.getsize(file_path)
            items.append({
                "id": row[0],
                "title": row[1],
                "description": row[2],
                "tags": row[3],
                "media_type": row[4],
                "filename": row[5],
                "file_size_bytes": file_size,
                "url": f"/uploads/{row[4]}s/{row[5]}"
            })

    conn.close()
    return items

# =======================
# Delete Media by ID
# =======================
@app.delete("/delete/{media_id}")
def delete_media(media_id: int):
    conn = sqlite3.connect("media.db")
    c = conn.cursor()
    c.execute("SELECT media_type, filename FROM media WHERE id = ?", (media_id,))
    row = c.fetchone()

    if not row:
        conn.close()
        raise HTTPException(status_code=404, detail="Media not found.")

    file_path = os.path.join("uploads", f"{row[0]}s", row[1])
    if os.path.exists(file_path):
        os.remove(file_path)

    c.execute("DELETE FROM media WHERE id = ?", (media_id,))
    conn.commit()
    conn.close()

    return {"message": "Media deleted successfully."}

# =======================
# Root
# =======================
@app.get("/", response_class=HTMLResponse)
def root():
    return "<h2>üåç WanderLens Backend Running</h2><p>Use /upload/, /media/, and /delete/{id} endpoints</p>"




(Model.py)
from sqlalchemy import Column, Integer, String
from .database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    full_name = Column(String)
    email = Column(String, unique=True, index=True)
    firebase_uid = Column(String, unique=True)



(database.py)
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from contextlib import contextmanager

# Define the DB URL (your password contains special characters, so it‚Äôs already correctly URL-encoded)
DATABASE_URL = "mysql+mysqlconnector://root:Tanaz2411##@localhost/wanderlens"

# Create SQLAlchemy engine and session
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base for all ORM models
Base = declarative_base()

# Dependency to get DB session in FastAPI
def get_db():
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()


(auth.py)
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext

SECRET_KEY = "wanderlenssupersecretkey"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password):
    return pwd_context.hash(password)

def verify_password(plain, hashed):
    return pwd_context.verify(plain, hashed)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)



(schemas.py)
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class UserOut(BaseModel):
    id: int
    username: str
    email: str

    class Config:
        orm_mode = True



Other Folders in backend(media, uploads(photos, videos)), __pycache__
